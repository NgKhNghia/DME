5 Our fault-tolerant algorithm
	Contrary to the fault tolerant extension proposed by Naimi and Trehel, we have modified the original algorithm in order to provide the same guarantees in terms of fault tolerance and to optimise efficiency and complexity in the occurence of failures.
5.1 Principle of the algorithm
	The guiding principle of our algorithm is to reconstruct the next queue by gathering intact portions of the previous next queue which existed just before the failure. The aim of this reconstruction is to preserve the initial order of token requests as much as possible and to avoid request retransmitions, as is the case in Naimi-Trehel’s solution. On the other hand, if the reconstruction is not possible, a new next queue will be created as well as a new last tree. The latter needs to be consistent with the former guaranteeing the invariant mentioned in section 3.
	Considering the original algorithm, a site always knows, through its next variable, which site will receive the token after it, i.e. its successor in next queue. However, it is not aware of which site will grant the token to it, neither which sites will get the token before it. In other words, it is not aware of its predecessors in next queue. Thus, in order to inform a node of its predecessor in next queue, we have added a confirmation mechanism to the original algorithm for each token request. Whenever a site Sj updates its next variable, i.e. Sj is in the last element of the next queue and received a token request, it sends a COMMIT message to the requester in order to confirm the reception of the request and to communicate the identification of its predecessors. The next queue then keeps a ordering where the smallest position corresponds to the site which has the token. A site loses its position when it leaves the queue. Initially the token holder has position zero. A COMMIT message sent to the requester Si, by site Sj , contains the two following informations:
	- The k predecessors of Si: k is a configurable parameter, indicating how many failures the algorithm can recover by using mechanism M1, described below.
	- Si’s position in the queue: equals to Si’s closest predecessor’s position + 1.
	The cost of having a predecessor information mechanism is low in terms of messages. We have added just one message per token request. Thus, the message complexity of the algorithm only grows from log(N) to log(N) + 1 and thus remains O(log(N)). However, this mechanism enables the detection of failures more effectively than Naimi-Trehel’s fault tolerant extension. In their approach, the reception of the token is controlled by a timer Twait, which depends both on latency (Tmsg) and the time (Tcs) for executing the critical section. In our approach, the same timer depends only on latency (Tmsg). After receiving a COMMIT message, Si periodically checks the liveness of its closest predecessor.
	After detecting a failure, site Si will start a failure recovery by executing a different mecanism for each of the three following cases :
	- Mechanism 1 (M1). Site Si has received a COMMIT message and there are less than k consecutive faulty sites in next queue.
	- Mechanism 2 (M2). Site Si received a COMMIT message, but there are more than k consecutive faulty sites in the next queue.
	- Mechanism 3 (M3). The site did not receive any COMMIT message.
	We now detail how to recover from failures in the three cases.
	M1. When site Si detects a failure of its closest predecessor, it sends an ARE YOU ALIVE message to each of its predecessors from the closest to the farthest, so as to check if they are still alive. It stops querying when it obtains an I AM ALIVE message from one of its predecessors. The latter then takes Si as its new successor, i.e. it sets its next variable to Si. The next queue is then reconstructed and the order is preserved. Furthermore, the last tree remains consistent with the next queue and the invariant mentioned in section 3 is asserted.
	M2. If no predecessor responded to the ARE YOU ALIVE message, Si will try to reconnect itself to next queue by diffusing a SEARCH PREV message which contains Si’s position. Si then arms a timer (2 ∗ Tmsg), waiting for the answer messages. All sites having a smaller position then Si’s will answer to it. After waiting 2 ∗ Tmsg, Si will choose among these sites, the one which has the greatest position to become its closest predecessor. Then, Si reconnects itself to this chosen site by sending a CONNECTION message to it. If Si does not receive any answer at all after 2∗Tmsg, it concludes that it has no predecessors and consequently the token has been lost. Si should then regenerate the token, initializing its position to zero.
	Observe that in both mechanisms M1 and M2, due to our predecessor information approach, the order of next queue is preserved.
	M3. We must consider now the case where the site which detects the failure has not received the COMMIT message yet, and therefore has no position in next queue. Moreover, in the absence of such information, several sites can detect the same failure simultaneously.
	M3.a We initially consider the situation when just one site Si detects the failure. In order to reconnect itself to next queue, Si will search for the site which has the greatest position. This search is initiated by the diffusion of a SEARCH QUEUE message. Si then arms a timer (2 ∗ Tmsg), waiting for the answer messages. A site that has a position in next queue answers to Si with an ACK SEARCH QUEUE message which contains its position in the next queue, as well as whether or not it has a next. Among all the received answers within 2 ∗ Tmsg, Si will select the site Sj with the greatest position. Si then considers three possibilities: 
	(i): Sj has informed that it has no next. Si then resends a token request to Sj . Notice that, since this request is sent directly to a node at the tail of next queue, Si does not use last tree to send a token request. Thus, we avoid the problem mentioned in section 3 concerning the instability of last tree when token requests are in transit.
	(ii): Sj has informed that it has a next. Si can conclude that Sj ’s next has failed. Si then sends a CONNECTION message to Sj in order to force Sj to reconnect itself to Si; i.e. Sj will set its next to Si.
	(iii): If site Si has not received any answer, it concludes that it has no more predecessors and that the token has been lost. Si can then regenerate the token, initializing its position to 0. It is sure to be the only site to regenerate the token.
	M3.b We now discuss the situation when several sites detect the node failure concurrently. They will start tracking the next queue, and will even generate a new token, which may bring next queue to an inconsistent state or the loss of the token uniqueness property. An election mechanism then is necessary. We consider that a site is elected if it is always candidate after a time of 2 ∗ Tmsg.
	Having sent a SEARCH QUEUE message to the other sites as described above, site Si is a candidate to reconnect to next queue. However, if Si receives a SEARCH QUEUE message from node Sj , it knows that another site Sj is also a candidate for reconnection. Thus, if Sj has made fewer accesses to the critical section than Si (this information is included in the SEARCH QUEUE message) or Si’s access number is equal to Sj ’s but Sj has a greater identifier than Si, the latter loses the election, sending a token request to Sj. In turn, Sj will be responsible for reconnecting itself to next queue. If Sj later loses the election, it will behave like Si. However, if it wins the election, it finds itself in the situation of mechanism M3.a. Next queue is thus repaired.
	Contrary to the first two mechanisms, the order of previous token requests is not preserved in mechanism M3. Thus, last tree must be reconstructed to be consistent with the new next queue. However, this reconstruction is done dynamically, without any additional overhead in terms of message and latency, since all the information a site needs has been transmitted to it in the SEARCH QUEUE message. Considering that Si is the single site that suspected the fault (M3.a), or the one that wins the election (M3.b), last tree is reconstructed as follows:
	I: all sites which do not wait for the token set their last variable to Si.
	II: all sites that have a position in next queue set their last variable to Si.
	III: all sites without a position, but in wait for the token, set their next variable to the same value as their last variable.
	An example of failure recovery based on mechanism M3 is shown in figure 2. We consider that there are two faulty sites, as shown in figure 2.a. The next queue is broken into two portions (G,H and A,B,C). Sites G and H have already obtained a position in next queue, but sites A, B and C have not. The token is held by site G, first site of the next queue. We also consider that site D had sent a token request to one of the two faulty sites and while waiting for the COMMIT message, it accepted a token request from E. Thus, there is a second queue of sites waiting for the token, but it is not connected to next queue yet. Notice that in such configuration last tree is also broken (the last variable values of sites F, G, H and D have become useless).
	Suppose that sites A and D detect a node failure concurrently. Both of them broadcast a SEARCH QUEUE message. We then say that A wins the election, i.e. A is the elected node. In figure 2.b, we can see how some of the last variables are updated. Having a position, sites G and H update their last to A (see II), as well as site F, which was not waiting for the token (see I). However, A, B and E, which are waiting for the token but do not have a position, update their last variables to the same value as their respective next variables (see III).
	When receiving the ACK SEARCH QUEUE message from H, site A can conclude that the next of H is a faulty site (see ii). A then sends a CONNECTION message to H. When the latter receives such a message, it sets its next variable to A. On the other hand, since site D lost the election, it sends a token request to the elected node (A). When receiving D’s request, A forwards this request to its last (lastA = B). The request travels along last tree, arriving at C, the root of the tree. All sites belonging to last path which received the request update their last variable to D. Site C sets its next variable to D, sending a COMMIT message to it. Figure 2.c shows the final configuration, considering that sites D et E have not received a COMMIT message yet.
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
5 Thuật toán chịu lỗi của chúng tôi
	Trái ngược với phần mở rộng chịu lỗi do Naimi và Trehel đề xuất, chúng tôi đã sửa đổi thuật toán gốc để cung cấp các đảm bảo tương tự về khả năng chịu lỗi và tối ưu hóa hiệu quả và độ phức tạp khi xảy ra lỗi.
5.1 Nguyên tắc của thuật toán
	Nguyên tắc chỉ đạo của thuật toán của chúng tôi là tái tạo hàng đợi tiếp theo bằng cách thu thập các phần nguyên vẹn của hàng đợi tiếp theo trước đó tồn tại ngay trước khi xảy ra lỗi. Mục đích của việc tái tạo này là bảo toàn thứ tự ban đầu của các yêu cầu mã thông báo càng nhiều càng tốt và tránh việc truyền lại yêu cầu, như trường hợp trong giải pháp của Naimi-Trehel. Mặt khác, nếu không thể tái tạo, một hàng đợi tiếp theo mới sẽ được tạo cũng như một cây cuối cùng mới. Cây sau cần phải nhất quán với cây trước đảm bảo bất biến được đề cập trong phần 3.
	Xem xét thuật toán gốc, một trang web luôn biết, thông qua biến tiếp theo của nó, trang web nào sẽ nhận được mã thông báo sau nó, tức là trang web kế nhiệm của nó trong hàng đợi tiếp theo. Tuy nhiên, nó không biết site nào sẽ cấp token cho nó, cũng như site nào sẽ nhận được token trước nó. Nói cách khác, nó không biết những site tiền nhiệm của nó trong hàng đợi tiếp theo. Do đó, để thông báo cho một nút về site tiền nhiệm của nó trong hàng đợi tiếp theo, chúng tôi đã thêm một cơ chế xác nhận vào thuật toán gốc cho mỗi yêu cầu token. Bất cứ khi nào một site Sj cập nhật biến tiếp theo của nó, tức là Sj nằm trong phần tử cuối cùng của hàng đợi tiếp theo và nhận được yêu cầu token, nó sẽ gửi một thông báo COMMIT đến người yêu cầu để xác nhận việc tiếp nhận yêu cầu và để thông báo nhận dạng của những site tiền nhiệm của nó. Sau đó, hàng đợi tiếp theo sẽ giữ một thứ tự trong đó vị trí nhỏ nhất tương ứng với site có token. Một site mất vị trí của mình khi nó rời khỏi hàng đợi. Ban đầu, người giữ token có vị trí bằng không. Một thông báo COMMIT được gửi đến người yêu cầu Si, bởi site Sj, chứa hai thông tin sau:
	- k tiền nhiệm của Si: k là một tham số có thể định cấu hình, cho biết thuật toán có thể phục hồi bao nhiêu lỗi bằng cách sử dụng cơ chế M1, được mô tả bên dưới.
	- Vị trí của Si trong hàng đợi: bằng với vị trí của Si gần nhất trước đó + 1.
	Chi phí để có cơ chế thông tin của người tiền nhiệm thấp về mặt tin nhắn. Chúng tôi chỉ thêm một tin nhắn cho mỗi yêu cầu mã thông báo. Do đó, độ phức tạp của tin nhắn của thuật toán chỉ tăng từ log(N) đến log(N) + 1 và do đó vẫn là O(log(N)). Tuy nhiên, cơ chế này cho phép phát hiện lỗi hiệu quả hơn so với phần mở rộng chịu lỗi của Naimi-Trehel. Trong cách tiếp cận của họ, việc tiếp nhận mã thông báo được kiểm soát bởi bộ đếm thời gian Twait, phụ thuộc vào cả độ trễ (Tmsg) và thời gian (Tcs) để thực hiện phần quan trọng. Trong cách tiếp cận của chúng tôi, cùng một bộ đếm thời gian chỉ phụ thuộc vào độ trễ (Tmsg). Sau khi nhận được tin nhắn COMMIT, Si sẽ kiểm tra định kỳ tính hoạt động của người tiền nhiệm gần nhất.
	Sau khi phát hiện lỗi, site Si sẽ bắt đầu khôi phục lỗi bằng cách thực hiện một cơ chế khác nhau cho mỗi trường hợp sau:
	- Cơ chế 1 (M1). Site Si đã nhận được tin nhắn COMMIT và có ít hơn k site lỗi liên tiếp trong hàng đợi tiếp theo.
	- Cơ chế 2 (M2). Site Si nhận được thông báo COMMIT, nhưng có hơn k site lỗi liên tiếp trong hàng đợi tiếp theo.
	- Cơ chế 3 (M3). Site không nhận được bất kỳ thông báo COMMIT nào.
	Bây giờ chúng ta sẽ trình bày chi tiết cách phục hồi sau lỗi trong ba trường hợp.
	M1. Khi site Si phát hiện lỗi của site tiền nhiệm gần nhất, nó sẽ gửi thông báo ARE YOU ALIVE đến từng site tiền nhiệm từ gần nhất đến xa nhất để kiểm tra xem chúng có còn hoạt động không. Nó dừng truy vấn khi nhận được thông báo I AM ALIVE từ một trong những site tiền nhiệm. Sau đó, site sau sẽ lấy Si làm site kế nhiệm mới, tức là nó đặt biến tiếp theo thành Si. Hàng đợi tiếp theo sau đó được xây dựng lại và thứ tự được bảo toàn. Hơn nữa, cây cuối cùng vẫn nhất quán với hàng đợi tiếp theo và bất biến được đề cập trong phần 3 được khẳng định.
	M2. Nếu không có site tiền nhiệm nào phản hồi thông báo ARE YOU ALIVE, Si sẽ cố gắng kết nối lại với hàng đợi tiếp theo bằng cách khuếch tán thông báo SEARCH PREV có chứa vị trí của Si. Si sau đó sẽ kích hoạt bộ đếm thời gian (2 ∗ Tmsg), chờ tin nhắn trả lời. Tất cả các site có vị trí nhỏ hơn Si sẽ trả lời. Sau khi chờ 2 ∗ Tmsg, Si sẽ chọn trong số các site này, site có vị trí lớn nhất để trở thành site tiền nhiệm gần nhất của nó. Sau đó, Si kết nối lại với site đã chọn này bằng cách gửi tin nhắn KẾT NỐI đến site đó. Nếu Si không nhận được bất kỳ câu trả lời nào sau 2∗Tmsg, nó kết luận rằng nó không có site tiền nhiệm nào và do đó mã thông báo đã bị mất. Sau đó, Si sẽ tạo lại mã thông báo, khởi tạo vị trí của nó thành 0.
	Lưu ý rằng trong cả hai cơ chế M1 và M2, do cách tiếp cận thông tin tiền nhiệm của chúng tôi, thứ tự của hàng đợi tiếp theo được bảo toàn.
	M3. Bây giờ chúng ta phải xem xét trường hợp site phát hiện lỗi vẫn chưa nhận được tin nhắn COMMIT và do đó không có vị trí trong hàng đợi tiếp theo. Hơn nữa, nếu không có thông tin như vậy, nhiều trang web có thể phát hiện cùng một lỗi cùng một lúc.
	M3.a Ban đầu chúng ta xem xét tình huống khi chỉ có một vị trí Si phát hiện ra lỗi. Để kết nối lại với hàng đợi tiếp theo, Si sẽ tìm kiếm trang web có vị trí lớn nhất. Tìm kiếm này được bắt đầu bằng việc phát tán thông điệp HÀNG ĐỢI TÌM KIẾM. Sau đó kích hoạt bộ đếm thời gian (2 ∗ Tmsg), chờ tin nhắn trả lời. Một trang web có vị trí trong hàng đợi tiếp theo sẽ phản hồi Si bằng tin nhắn ACK SEARCH QUEUE chứa vị trí của trang web đó trong hàng đợi tiếp theo cũng như thông tin về việc trang web đó có trang web tiếp theo hay không. Trong số tất cả các câu trả lời nhận được trong vòng 2 ∗ Tmsg, Si sẽ chọn vị trí Sj có vị trí lớn nhất. Sau đó Si xem xét ba khả năng:
	(i): Sj đã thông báo là không có tiếp theo. Sau đó Si gửi lại yêu cầu mã thông báo tới Sj. Lưu ý rằng, vì yêu cầu này được gửi trực tiếp đến một nút ở cuối hàng đợi tiếp theo nên Si không sử dụng cây cuối cùng để gửi yêu cầu mã thông báo. Do đó, chúng ta tránh được vấn đề được đề cập ở phần 3 liên quan đến tính không ổn định của cây cuối cùng khi các yêu cầu mã thông báo đang được chuyển tiếp.
	(ii): Sj đã thông báo rằng nó có một cái tiếp theo. Làm sao bạn có thể kết luận rằng Sj tiếp theo đã thất bại? Sau đó Si gửi tin nhắn KẾT NỐI tới Sj để buộc Sj kết nối lại với Si; tức là Sj sẽ đặt cạnh Si.
	(iii): Nếu trang Si không nhận được bất kỳ câu trả lời nào, nó kết luận rằng nó không còn người tiền nhiệm nào nữa và mã thông báo đã bị mất. Vậy thì làm sao bạn có thể tạo lại mã thông báo, khởi tạo vị trí của nó thành 0? Chắc chắn đây là trang web duy nhất có thể tạo lại mã thông báo.
	M3.b Bây giờ chúng ta thảo luận về tình huống khi nhiều địa điểm phát hiện lỗi nút cùng lúc. Họ sẽ bắt đầu theo dõi hàng đợi tiếp theo và thậm chí tạo ra một mã thông báo mới, điều này có thể khiến hàng đợi tiếp theo rơi vào trạng thái không nhất quán hoặc mất tính duy nhất của mã thông báo. Khi đó cần phải có cơ chế bầu cử. Chúng tôi coi một trang web được bầu nếu nó luôn là ứng cử viên sau khoảng thời gian là 2 ∗ Tmsg.
	Sau khi gửi tin nhắn HÀNG ĐỢI TÌM KIẾM đến các trang web khác như mô tả ở trên, trang web Si có thể kết nối lại với hàng đợi tiếp theo. Tuy nhiên, nếu Si nhận được tin nhắn HÀNG ĐỢI TÌM KIẾM từ nút Sj, nó biết rằng một trang web khác Sj cũng là ứng cử viên để kết nối lại. Do đó, nếu Sj truy cập vào phần quan trọng ít hơn Si (thông tin này được bao gồm trong tin nhắn HÀNG ĐỢI TÌM KIẾM) hoặc số truy cập của Si bằng với Sj nhưng Sj có mã định danh lớn hơn Si, thì Si sẽ thua cuộc bầu cử, gửi một yêu cầu mã thông báo cho Sj. Đến lượt mình, Sj sẽ chịu trách nhiệm kết nối lại với hàng đợi tiếp theo. Nếu sau này Sj thua cuộc bầu cử, nó sẽ hành xử giống như Si. Tuy nhiên, nếu thắng cử, nó sẽ thấy mình trong tình huống của cơ chế M3.a. Hàng đợi tiếp theo do đó đã được sửa chữa.
	Trái ngược với hai cơ chế đầu tiên, thứ tự của các yêu cầu mã thông báo trước đó không được bảo toàn trong cơ chế M3. Vì vậy, cây cuối cùng phải được xây dựng lại để phù hợp với hàng đợi tiếp theo mới. Tuy nhiên, quá trình tái tạo này được thực hiện một cách linh hoạt, không có bất kỳ chi phí bổ sung nào về mặt tin nhắn và độ trễ, vì mọi thông tin mà một trang web cần đã được truyền đến trang web đó trong tin nhắn HÀNG ĐỢI TÌM KIẾM. Xét rằng Si là địa điểm duy nhất nghi ngờ lỗi (M3.a) hoặc là địa điểm chiến thắng trong cuộc bầu cử (M3.b), cây cuối cùng được xây dựng lại như sau:
	I: tất cả các trang web không chờ mã thông báo sẽ đặt biến cuối cùng thành Có.
	II: tất cả các trang web có vị trí trong hàng đợi tiếp theo sẽ đặt biến cuối cùng của chúng thành Si.
	III: tất cả các trang web không có vị trí nhưng đang chờ mã thông báo, đặt biến tiếp theo của chúng thành cùng giá trị với biến cuối cùng của chúng.
	Một ví dụ về phục hồi lỗi dựa trên cơ chế M3 được thể hiện ở hình 2. Chúng tôi coi rằng có hai vị trí lỗi, như thể hiện ở hình 2.a. Hàng đợi tiếp theo được chia thành hai phần (G, H và A, B, C). Các trang web G và H đã có được vị trí trong hàng đợi tiếp theo, nhưng các trang web A, B và C thì chưa. Mã thông báo được giữ bởi trang web G, trang web đầu tiên của hàng đợi tiếp theo. Chúng tôi cũng xem xét rằng trang web D đã gửi yêu cầu mã thông báo đến một trong hai trang web bị lỗi và trong khi chờ tin nhắn COMMIT, nó đã chấp nhận yêu cầu mã thông báo từ E. Do đó, có một hàng đợi thứ hai của các trang web đang chờ mã thông báo, nhưng nó chưa được kết nối với hàng đợi tiếp theo. Lưu ý rằng trong cấu hình như vậy, cây cuối cùng cũng bị hỏng (các giá trị biến cuối cùng của các trang F, G, H và D đã trở nên vô dụng).
	Giả sử các trang web A và D phát hiện lỗi nút cùng một lúc. Cả hai đều phát đi thông điệp HÀNG ĐỢI TÌM KIẾM. Khi đó ta nói A thắng cử, tức là A là nút được bầu. Trong hình 2.b, chúng ta có thể thấy cách một số biến cuối cùng được cập nhật. Khi có vị trí, các trang web G và H cập nhật vị trí cuối cùng của chúng lên A (xem II), cũng như trang web F, không chờ mã thông báo (xem I). Tuy nhiên, A, B và E đang chờ mã thông báo nhưng không có vị trí, sẽ cập nhật các biến cuối cùng của chúng thành cùng giá trị với các biến tiếp theo tương ứng của chúng (xem III). Khi nhận được tin nhắn ACK SEARCH QUEUE từ H, trang A có thể kết luận rằng trang tiếp theo của H là trang bị lỗi (xem ii). Sau đó, A gửi tin nhắn KẾT NỐI tới H. Khi H nhận được tin nhắn như vậy, nó sẽ đặt biến tiếp theo thành A. Mặt khác, vì trang web D thua cuộc bầu cử nên nó sẽ gửi yêu cầu mã thông báo tới nút được bầu (A). Khi nhận được yêu cầu của D, A chuyển tiếp yêu cầu này đến yêu cầu cuối cùng của mình (lastA = B). Yêu cầu di chuyển dọc theo cây cuối cùng và đến C, gốc của cây. Tất cả các trang web thuộc đường dẫn cuối cùng nhận được yêu cầu sẽ cập nhật biến cuối cùng của chúng thành D. Trang web C đặt biến tiếp theo của mình thành D, đồng thời gửi thông báo COMMIT đến trang web này. Hình 2.c hiển thị cấu hình cuối cùng, xét đến việc các trang web D và E vẫn chưa nhận được thông báo COMMIT.
