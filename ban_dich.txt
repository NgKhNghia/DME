5 Our fault-tolerant algorithm
	Contrary to the fault tolerant extension proposed by Naimi and Trehel, we have modified the original algorithm in order to provide the same guarantees in terms of fault tolerance and to optimise efficiency and complexity in the occurence of failures.
5.1 Principle of the algorithm
	The guiding principle of our algorithm is to reconstruct the next queue by gathering intact portions of the previous next queue which existed just before the failure. The aim of this reconstruction is to preserve the initial order of token requests as much as possible and to avoid request retransmitions, as is the case in Naimi-Trehel’s solution. On the other hand, if the reconstruction is not possible, a new next queue will be created as well as a new last tree. The latter needs to be consistent with the former guaranteeing the invariant mentioned in section 3.
	Considering the original algorithm, a site always knows, through its next variable, which site will receive the token after it, i.e. its successor in next queue. However, it is not aware of which site will grant the token to it, neither which sites will get the token before it. In other words, it is not aware of its predecessors in next queue. Thus, in order to inform a node of its predecessor in next queue, we have added a confirmation mechanism to the original algorithm for each token request. Whenever a site Sj updates its next variable, i.e. Sj is in the last element of the next queue and received a token request, it sends a COMMIT message to the requester in order to confirm the reception of the request and to communicate the identification of its predecessors. The next queue then keeps a ordering where the smallest position corresponds to the site which has the token. A site loses its position when it leaves the queue. Initially the token holder has position zero. A COMMIT message sent to the requester Si, by site Sj , contains the two following informations:
	- The k predecessors of Si: k is a configurable parameter, indicating how many failures the algorithm can recover by using mechanism M1, described below.
	- Si’s position in the queue: equals to Si’s closest predecessor’s position + 1.
	The cost of having a predecessor information mechanism is low in terms of messages. We have added just one message per token request. Thus, the message complexity of the algorithm only grows from log(N) to log(N) + 1 and thus remains O(log(N)). However, this mechanism enables the detection of failures more effectively than Naimi-Trehel’s fault tolerant extension. In their approach, the reception of the token is controlled by a timer Twait, which depends both on latency (Tmsg) and the time (Tcs) for executing the critical section. In our approach, the same timer depends only on latency (Tmsg). After receiving a COMMIT message, Si periodically checks the liveness of its closest predecessor.
	After detecting a failure, site Si will start a failure recovery by executing a different mecanism for each of the three following cases :
	- Mechanism 1 (M1). Site Si has received a COMMIT message and there are less than k consecutive faulty sites in next queue.
	- Mechanism 2 (M2). Site Si received a COMMIT message, but there are more than k consecutive faulty sites in the next queue.
	- Mechanism 3 (M3). The site did not receive any COMMIT message.
	We now detail how to recover from failures in the three cases.
	M1. When site Si detects a failure of its closest predecessor, it sends an ARE YOU ALIVE message to each of its predecessors from the closest to the farthest, so as to check if they are still alive. It stops querying when it obtains an I AM ALIVE message from one of its predecessors. The latter then takes Si as its new successor, i.e. it sets its next variable to Si. The next queue is then reconstructed and the order is preserved. Furthermore, the last tree remains consistent with the next queue and the invariant mentioned in section 3 is asserted.
	M2. If no predecessor responded to the ARE YOU ALIVE message, Si will try to reconnect itself to next queue by diffusing a SEARCH PREV message which contains Si’s position. Si then arms a timer (2 ∗ Tmsg), waiting for the answer messages. All sites having a smaller position then Si’s will answer to it. After waiting 2 ∗ Tmsg, Si will choose among these sites, the one which has the greatest position to become its closest predecessor. Then, Si reconnects itself to this chosen site by sending a CONNECTION message to it. If Si does not receive any answer at all after 2∗Tmsg, it concludes that it has no predecessors and consequently the token has been lost. Si should then regenerate the token, initializing its position to zero.
	Observe that in both mechanisms M1 and M2, due to our predecessor information approach, the order of next queue is preserved.
	M3. We must consider now the case where the site which detects the failure has not received the COMMIT message yet, and therefore has no position in next queue. Moreover, in the absence of such information, several sites can detect the same failure simultaneously.
	M3.a We initially consider the situation when just one site Si detects the failure. In order to reconnect itself to next queue, Si will search for the site which has the greatest position. This search is initiated by the diffusion of a SEARCH QUEUE message. Si then arms a timer (2 ∗ Tmsg), waiting for the answer messages. A site that has a position in next queue answers to Si with an ACK SEARCH QUEUE message which contains its position in the next queue, as well as whether or not it has a next. Among all the received answers within 2 ∗ Tmsg, Si will select the site Sj with the greatest position. Si then considers three possibilities: 
	(i): Sj has informed that it has no next. Si then resends a token request to Sj . Notice that, since this request is sent directly to a node at the tail of next queue, Si does not use last tree to send a token request. Thus, we avoid the problem mentioned in section 3 concerning the instability of last tree when token requests are in transit.
	(ii): Sj has informed that it has a next. Si can conclude that Sj ’s next has failed. Si then sends a CONNECTION message to Sj in order to force Sj to reconnect itself to Si; i.e. Sj will set its next to Si.
	(iii): If site Si has not received any answer, it concludes that it has no more predecessors and that the token has been lost. Si can then regenerate the token, initializing its position to 0. It is sure to be the only site to regenerate the token.
	M3.b We now discuss the situation when several sites detect the node failure concurrently. They will start tracking the next queue, and will even generate a new token, which may bring next queue to an inconsistent state or the loss of the token uniqueness property. An election mechanism then is necessary. We consider that a site is elected if it is always candidate after a time of 2 ∗ Tmsg.
	Having sent a SEARCH QUEUE message to the other sites as described above, site Si is a candidate to reconnect to next queue. However, if Si receives a SEARCH QUEUE message from node Sj , it knows that another site Sj is also a candidate for reconnection. Thus, if Sj has made fewer accesses to the critical section than Si (this information is included in the SEARCH QUEUE message) or Si’s access number is equal to Sj ’s but Sj has a greater identifier than Si, the latter loses the election, sending a token request to Sj. In turn, Sj will be responsible for reconnecting itself to next queue. If Sj later loses the election, it will behave like Si. However, if it wins the election, it finds itself in the situation of mechanism M3.a. Next queue is thus repaired.
	Contrary to the first two mechanisms, the order of previous token requests is not preserved in mechanism M3. Thus, last tree must be reconstructed to be consistent with the new next queue. However, this reconstruction is done dynamically, without any additional overhead in terms of message and latency, since all the information a site needs has been transmitted to it in the SEARCH QUEUE message. Considering that Si is the single site that suspected the fault (M3.a), or the one that wins the election (M3.b), last tree is reconstructed as follows:
	I: all sites which do not wait for the token set their last variable to Si.
	II: all sites that have a position in next queue set their last variable to Si.
	III: all sites without a position, but in wait for the token, set their next variable to the same value as their last variable.
	An example of failure recovery based on mechanism M3 is shown in figure 2. We consider that there are two faulty sites, as shown in figure 2.a. The next queue is broken into two portions (G,H and A,B,C). Sites G and H have already obtained a position in next queue, but sites A, B and C have not. The token is held by site G, first site of the next queue. We also consider that site D had sent a token request to one of the two faulty sites and while waiting for the COMMIT message, it accepted a token request from E. Thus, there is a second queue of sites waiting for the token, but it is not connected to next queue yet. Notice that in such configuration last tree is also broken (the last variable values of sites F, G, H and D have become useless).
	Suppose that sites A and D detect a node failure concurrently. Both of them broadcast a SEARCH QUEUE message. We then say that A wins the election, i.e. A is the elected node. In figure 2.b, we can see how some of the last variables are updated. Having a position, sites G and H update their last to A (see II), as well as site F, which was not waiting for the token (see I). However, A, B and E, which are waiting for the token but do not have a position, update their last variables to the same value as their respective next variables (see III).
	When receiving the ACK SEARCH QUEUE message from H, site A can conclude that the next of H is a faulty site (see ii). A then sends a CONNECTION message to H. When the latter receives such a message, it sets its next variable to A. On the other hand, since site D lost the election, it sends a token request to the elected node (A). When receiving D’s request, A forwards this request to its last (lastA = B). The request travels along last tree, arriving at C, the root of the tree. All sites belonging to last path which received the request update their last variable to D. Site C sets its next variable to D, sending a COMMIT message to it. Figure 2.c shows the final configuration, considering that sites D et E have not received a COMMIT message yet.
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
5. Thuật toán chịu lỗi của chúng tôi

Khác với mở rộng chịu lỗi được đề xuất bởi Naimi và Trehel, chúng tôi đã sửa đổi thuật toán gốc để cung cấp các đảm bảo tương tự về khả năng chịu lỗi và tối ưu hóa hiệu quả cũng như độ phức tạp khi xảy ra sự cố.

5.1 Nguyên lý của thuật toán

Nguyên lý cơ bản của thuật toán của chúng tôi là tái tạo hàng đợi tiếp theo bằng cách thu thập các phần còn nguyên vẹn của hàng đợi tiếp theo trước đó, vốn tồn tại ngay trước khi xảy ra sự cố. Mục tiêu của việc tái tạo này là bảo tồn thứ tự ban đầu của các yêu cầu token càng nhiều càng tốt và tránh việc truyền lại các yêu cầu, như trong giải pháp của Naimi-Trehel. Mặt khác, nếu việc tái tạo là không thể, một hàng đợi tiếp theo mới sẽ được tạo ra cùng với một cây cuối mới. Cây này cần phải nhất quán với cây trước đó, đảm bảo tính bất biến đã được đề cập trong phần 3.

Xét về thuật toán gốc, một site luôn biết, thông qua biến next của mình, site nào sẽ nhận token sau nó, tức là người kế tiếp trong hàng đợi tiếp theo. Tuy nhiên, nó không biết site nào sẽ cấp token cho nó, cũng như những site nào sẽ nhận token trước nó. Nói cách khác, nó không biết về các tiền nhiệm trong hàng đợi tiếp theo. Do đó, để thông báo cho một node về tiền nhiệm của nó trong hàng đợi tiếp theo, chúng tôi đã thêm một cơ chế xác nhận vào thuật toán gốc cho mỗi yêu cầu token. Mỗi khi một site Sj cập nhật biến next của nó, tức là Sj đang ở phần tử cuối cùng của hàng đợi tiếp theo và nhận được yêu cầu token, nó sẽ gửi một thông báo COMMIT cho người yêu cầu để xác nhận việc nhận yêu cầu và thông báo về nhận dạng của các tiền nhiệm của nó. Hàng đợi tiếp theo sau đó giữ một thứ tự, trong đó vị trí nhỏ nhất tương ứng với site có token. Một site sẽ mất vị trí khi nó rời khỏi hàng đợi. Ban đầu, người nắm giữ token có vị trí bằng không. Một thông báo COMMIT gửi cho người yêu cầu Si, từ site Sj, chứa hai thông tin sau:

K tiền nhiệm của Si: k là một tham số có thể cấu hình, chỉ ra số lượng sự cố mà thuật toán có thể khôi phục bằng cách sử dụng cơ chế M1, được mô tả dưới đây.
Vị trí của Si trong hàng đợi: bằng vị trí của tiền nhiệm gần nhất của Si cộng thêm 1.
Chi phí của cơ chế thông tin tiền nhiệm là thấp về mặt số lượng tin nhắn. Chúng tôi chỉ thêm một tin nhắn cho mỗi yêu cầu token. Do đó, độ phức tạp tin nhắn của thuật toán chỉ tăng từ log(N) lên log(N) + 1 và vẫn duy trì O(log(N)). Tuy nhiên, cơ chế này cho phép phát hiện sự cố hiệu quả hơn so với mở rộng chịu lỗi của Naimi-Trehel. Trong phương pháp của họ, việc nhận token được kiểm soát bởi một bộ đếm thời gian Twait, phụ thuộc vào độ trễ (Tmsg) và thời gian (Tcs) để thực thi phần vùng quan trọng. Trong phương pháp của chúng tôi, bộ đếm thời gian này chỉ phụ thuộc vào độ trễ (Tmsg). Sau khi nhận được một thông báo COMMIT, Si sẽ kiểm tra định kỳ sự sống sót của tiền nhiệm gần nhất của nó.

Sau khi phát hiện sự cố, site Si sẽ bắt đầu phục hồi sự cố bằng cách thực thi một cơ chế khác nhau cho ba trường hợp sau đây:

Cơ chế 1 (M1). Site Si đã nhận được một thông báo COMMIT và có ít hơn k site bị lỗi liên tiếp trong hàng đợi tiếp theo.
Cơ chế 2 (M2). Site Si đã nhận được một thông báo COMMIT, nhưng có hơn k site bị lỗi liên tiếp trong hàng đợi tiếp theo.
Cơ chế 3 (M3). Site không nhận được bất kỳ thông báo COMMIT nào.
Bây giờ chúng tôi sẽ chi tiết cách phục hồi từ sự cố trong ba trường hợp.

M1. Khi site Si phát hiện sự cố của tiền nhiệm gần nhất của mình, nó sẽ gửi một tin nhắn ARE YOU ALIVE đến từng tiền nhiệm của nó từ gần nhất đến xa nhất, để kiểm tra xem chúng còn sống hay không. Nó sẽ dừng truy vấn khi nhận được một tin nhắn I AM ALIVE từ một trong các tiền nhiệm. Tiền nhiệm này sau đó sẽ coi Si là người kế tiếp của mình, tức là nó sẽ đặt biến next của mình thành Si. Hàng đợi tiếp theo sau đó được tái tạo và thứ tự được bảo tồn. Hơn nữa, cây cuối vẫn nhất quán với hàng đợi tiếp theo và tính bất biến được đề cập trong phần 3 được xác nhận.

M2. Nếu không có tiền nhiệm nào phản hồi lại tin nhắn ARE YOU ALIVE, Si sẽ cố gắng kết nối lại với hàng đợi tiếp theo bằng cách phát tán một tin nhắn SEARCH PREV chứa vị trí của Si. Si sau đó sẽ cài đặt một bộ đếm thời gian (2 ∗ Tmsg), chờ các tin nhắn trả lời. Tất cả các site có vị trí nhỏ hơn Si sẽ trả lời lại. Sau khi chờ đợi 2 ∗ Tmsg, Si sẽ chọn trong số các site này, site có vị trí lớn nhất để trở thành tiền nhiệm gần nhất của nó. Sau đó, Si sẽ kết nối lại với site này bằng cách gửi một tin nhắn CONNECTION. Nếu Si không nhận được bất kỳ phản hồi nào sau 2 ∗ Tmsg, nó sẽ kết luận rằng nó không có tiền nhiệm và do đó token đã bị mất. Si sau đó cần phải tái tạo token, khởi tạo vị trí của nó bằng không.

M3. Bây giờ chúng ta cần xem xét trường hợp mà site phát hiện sự cố chưa nhận được thông báo COMMIT và do đó không có vị trí trong hàng đợi tiếp theo. Hơn nữa, trong trường hợp không có thông tin như vậy, nhiều site có thể phát hiện cùng một sự cố đồng thời.

M3.a Chúng ta sẽ xem xét tình huống khi chỉ có một site Si phát hiện sự cố. Để kết nối lại với hàng đợi tiếp theo, Si sẽ tìm kiếm site có vị trí lớn nhất. Việc tìm kiếm này được bắt đầu bằng cách phát tán một tin nhắn SEARCH QUEUE. Si sau đó cài đặt bộ đếm thời gian (2 ∗ Tmsg), chờ các tin nhắn trả lời. Một site có vị trí trong hàng đợi tiếp theo sẽ trả lời Si với một tin nhắn ACK SEARCH QUEUE chứa vị trí của nó trong hàng đợi tiếp theo, cũng như việc nó có next hay không. Trong số tất cả các tin nhắn nhận được trong vòng 2 ∗ Tmsg, Si sẽ chọn site Sj có vị trí lớn nhất. Si sau đó sẽ xem xét ba khả năng: 

(i) Sj thông báo rằng nó không có next. Si sẽ gửi lại yêu cầu token cho Sj. Lưu ý rằng, vì yêu cầu này được gửi trực tiếp đến một node ở cuối hàng đợi tiếp theo, Si không sử dụng cây cuối để gửi yêu cầu token. Do đó, chúng ta tránh được vấn đề đã đề cập trong phần 3 liên quan đến sự không ổn định của cây cuối khi các yêu cầu token đang trong quá trình truyền.

(ii) Sj thông báo rằng nó có next. Si có thể kết luận rằng next của Sj đã bị lỗi. Si sẽ gửi một tin nhắn CONNECTION cho Sj để buộc Sj kết nối lại với Si; tức là Sj sẽ đặt next của mình thành Si.

(iii) Nếu site Si không nhận được bất kỳ tin nhắn nào, nó kết luận rằng nó không còn tiền nhiệm và token đã bị mất. Si sau đó có thể tái tạo token, khởi tạo vị trí của nó bằng 0. Nó chắc chắn là site duy nhất tái tạo token.

M3.b Chúng ta sẽ thảo luận về tình huống khi nhiều site phát hiện sự cố đồng thời. Các site này sẽ bắt đầu theo dõi hàng đợi tiếp theo và thậm chí sẽ tạo ra một token mới, điều này có thể đưa hàng đợi tiếp theo vào trạng thái không nhất quán hoặc làm mất tính duy nhất của token. Một cơ chế bầu cử sẽ cần thiết. Chúng tôi coi rằng một site sẽ được bầu chọn nếu nó luôn là ứng cử viên sau thời gian 2 ∗ Tmsg.

Sau khi gửi một tin nhắn SEARCH QUEUE đến các site khác như đã mô tả ở trên, site Si trở thành ứng cử viên để kết nối lại với hàng đợi tiếp theo. Tuy nhiên, nếu Si nhận được một tin nhắn SEARCH QUEUE từ node Sj, nó biết rằng một site khác Sj cũng là ứng cử viên cho việc kết nối lại. Vì vậy, nếu Sj đã truy cập vào phần vùng quan trọng ít hơn Si (thông tin này được bao gồm trong tin nhắn SEARCH QUEUE) hoặc nếu số lần truy cập của Si bằng số lần truy cập của Sj nhưng Sj có định danh lớn hơn Si, thì Si sẽ thua trong cuộc bầu cử và gửi yêu cầu token đến Sj. Đổi lại, Sj sẽ chịu trách nhiệm kết nối lại với hàng đợi tiếp theo. Nếu Sj sau đó thua trong cuộc bầu cử, nó sẽ cư xử như Si. Tuy nhiên, nếu Sj thắng cuộc bầu cử, nó sẽ rơi vào tình huống của cơ chế M3.a. Do đó, hàng đợi tiếp theo sẽ được sửa chữa.

Khác với hai cơ chế đầu tiên, thứ tự của các yêu cầu token trước đó không được bảo tồn trong cơ chế M3. Do đó, cây cuối phải được tái tạo lại để nhất quán với hàng đợi tiếp theo mới. Tuy nhiên, việc tái tạo này được thực hiện một cách động, không gây thêm chi phí về tin nhắn và độ trễ, vì tất cả thông tin mà một site cần đã được truyền đến nó trong tin nhắn SEARCH QUEUE. Xét rằng Si là site duy nhất nghi ngờ sự cố (M3.a), hoặc là site thắng cuộc bầu cử (M3.b), cây cuối được tái tạo như sau:

I: Tất cả các site không chờ token sẽ đặt biến last của chúng thành Si.

II: Tất cả các site có vị trí trong hàng đợi tiếp theo sẽ đặt biến last của chúng thành Si.

III: Tất cả các site không có vị trí, nhưng đang chờ token, sẽ đặt biến next của chúng thành giá trị giống như biến last của chúng.

Một ví dụ về phục hồi sự cố dựa trên cơ chế M3 được thể hiện trong hình 2. Chúng ta giả sử rằng có hai site bị lỗi, như thể hiện trong hình 2.a. Hàng đợi tiếp theo bị chia thành hai phần (G, H và A, B, C). Các site G và H đã có vị trí trong hàng đợi tiếp theo, nhưng các site A, B, và C thì chưa. Token được nắm giữ bởi site G, site đầu tiên trong hàng đợi tiếp theo. Chúng ta cũng giả sử rằng site D đã gửi một yêu cầu token tới một trong hai site bị lỗi và trong khi chờ tin nhắn COMMIT, nó đã nhận một yêu cầu token từ E. Do đó, có một hàng đợi thứ hai của các site đang chờ token, nhưng nó chưa được kết nối với hàng đợi tiếp theo. Lưu ý rằng trong cấu hình này, cây cuối cũng bị vỡ (các giá trị biến last của các site F, G, H, và D đã trở nên vô nghĩa).

Giả sử rằng các site A và D phát hiện sự cố đồng thời. Cả hai đều phát tán một tin nhắn SEARCH QUEUE. Chúng ta sẽ nói rằng A thắng trong cuộc bầu cử, tức là A là node được bầu chọn. Trong hình 2.b, chúng ta có thể thấy cách một số biến last được cập nhật. Các site G và H có vị trí đã cập nhật biến last của chúng thành A (xem II), cũng như site F, mặc dù không chờ token (xem I). Tuy nhiên, các site A, B, và E, mặc dù đang chờ token nhưng không có vị trí, sẽ cập nhật biến last của chúng thành giá trị giống như các biến next tương ứng của chúng (xem III).

Khi nhận được tin nhắn ACK SEARCH QUEUE từ H, site A có thể kết luận rằng next của H là một site bị lỗi (xem ii). A sau đó gửi một tin nhắn CONNECTION cho H. Khi H nhận được tin nhắn này, nó sẽ đặt biến next của mình thành A. Mặt khác, vì site D đã thua cuộc bầu cử, nó gửi yêu cầu token tới node đã thắng cuộc (A). Khi nhận được yêu cầu của D, A chuyển tiếp yêu cầu này đến last của mình (lastA = B). Yêu cầu này di chuyển qua cây cuối, đến C, gốc của cây. Tất cả các site thuộc đường dẫn cuối nhận yêu cầu này sẽ cập nhật biến last của chúng thành D. Site C sẽ đặt biến next của mình thành D, gửi một tin nhắn COMMIT đến D. Hình 2.c thể hiện cấu hình cuối cùng, xét rằng các site D và E chưa nhận được tin nhắn COMMIT.
